// Code generated by MockGen. DO NOT EDIT.
// Source: container.go

// Package exec is a generated GoMock package.
package exec

import (
	context "context"
	units "invoker/pkg/units"
	reflect "reflect"
	time "time"

	gomock "github.com/golang/mock/gomock"
)

// MockContainer is a mock of Container interface.
type MockContainer struct {
	ctrl     *gomock.Controller
	recorder *MockContainerMockRecorder
}

// MockContainerMockRecorder is the mock recorder for MockContainer.
type MockContainerMockRecorder struct {
	mock *MockContainer
}

// NewMockContainer creates a new mock instance.
func NewMockContainer(ctrl *gomock.Controller) *MockContainer {
	mock := &MockContainer{ctrl: ctrl}
	mock.recorder = &MockContainerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockContainer) EXPECT() *MockContainerMockRecorder {
	return m.recorder
}

// ID mocks base method.
func (m *MockContainer) ID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(string)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockContainerMockRecorder) ID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockContainer)(nil).ID))
}

// IP mocks base method.
func (m *MockContainer) IP() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IP")
	ret0, _ := ret[0].(string)
	return ret0
}

// IP indicates an expected call of IP.
func (mr *MockContainerMockRecorder) IP() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IP", reflect.TypeOf((*MockContainer)(nil).IP))
}

// Initialize mocks base method.
func (m *MockContainer) Initialize(ctx context.Context, payload ContainerInitPayload) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Initialize", ctx, payload)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Initialize indicates an expected call of Initialize.
func (mr *MockContainerMockRecorder) Initialize(ctx, payload interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Initialize", reflect.TypeOf((*MockContainer)(nil).Initialize), ctx, payload)
}

// Logs mocks base method.
func (m *MockContainer) Logs() <-chan LogLine {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Logs")
	ret0, _ := ret[0].(<-chan LogLine)
	return ret0
}

// Logs indicates an expected call of Logs.
func (mr *MockContainerMockRecorder) Logs() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Logs", reflect.TypeOf((*MockContainer)(nil).Logs))
}

// Pause mocks base method.
func (m *MockContainer) Pause(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Pause", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Pause indicates an expected call of Pause.
func (mr *MockContainerMockRecorder) Pause(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pause", reflect.TypeOf((*MockContainer)(nil).Pause), ctx)
}

// PauseEventually mocks base method.
func (m *MockContainer) PauseEventually(pauseGrace time.Duration) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "PauseEventually", pauseGrace)
}

// PauseEventually indicates an expected call of PauseEventually.
func (mr *MockContainerMockRecorder) PauseEventually(pauseGrace interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PauseEventually", reflect.TypeOf((*MockContainer)(nil).PauseEventually), pauseGrace)
}

// Remove mocks base method.
func (m *MockContainer) Remove(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Remove", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Remove indicates an expected call of Remove.
func (mr *MockContainerMockRecorder) Remove(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Remove", reflect.TypeOf((*MockContainer)(nil).Remove), ctx)
}

// Run mocks base method.
func (m *MockContainer) Run(ctx context.Context, payload ContainerRunPayload) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", ctx, payload)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Run indicates an expected call of Run.
func (mr *MockContainerMockRecorder) Run(ctx, payload interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockContainer)(nil).Run), ctx, payload)
}

// State mocks base method.
func (m *MockContainer) State(ctx context.Context) (ContainerState, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "State", ctx)
	ret0, _ := ret[0].(ContainerState)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// State indicates an expected call of State.
func (mr *MockContainerMockRecorder) State(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "State", reflect.TypeOf((*MockContainer)(nil).State), ctx)
}

// Unpause mocks base method.
func (m *MockContainer) Unpause(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unpause", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Unpause indicates an expected call of Unpause.
func (mr *MockContainerMockRecorder) Unpause(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unpause", reflect.TypeOf((*MockContainer)(nil).Unpause), ctx)
}

// UnpauseIfNeeded mocks base method.
func (m *MockContainer) UnpauseIfNeeded(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UnpauseIfNeeded", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// UnpauseIfNeeded indicates an expected call of UnpauseIfNeeded.
func (mr *MockContainerMockRecorder) UnpauseIfNeeded(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UnpauseIfNeeded", reflect.TypeOf((*MockContainer)(nil).UnpauseIfNeeded), ctx)
}

// MockContainerFactory is a mock of ContainerFactory interface.
type MockContainerFactory struct {
	ctrl     *gomock.Controller
	recorder *MockContainerFactoryMockRecorder
}

// MockContainerFactoryMockRecorder is the mock recorder for MockContainerFactory.
type MockContainerFactoryMockRecorder struct {
	mock *MockContainerFactory
}

// NewMockContainerFactory creates a new mock instance.
func NewMockContainerFactory(ctrl *gomock.Controller) *MockContainerFactory {
	mock := &MockContainerFactory{ctrl: ctrl}
	mock.recorder = &MockContainerFactoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockContainerFactory) EXPECT() *MockContainerFactoryMockRecorder {
	return m.recorder
}

// CreateContainer mocks base method.
func (m *MockContainerFactory) CreateContainer(ctx context.Context, kind string, memory units.ByteSize, name string) (Container, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateContainer", ctx, kind, memory, name)
	ret0, _ := ret[0].(Container)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateContainer indicates an expected call of CreateContainer.
func (mr *MockContainerFactoryMockRecorder) CreateContainer(ctx, kind, memory, name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateContainer", reflect.TypeOf((*MockContainerFactory)(nil).CreateContainer), ctx, kind, memory, name)
}
